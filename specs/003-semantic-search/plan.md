# Implementation Plan: Semantic Search

**Branch**: `003-semantic-search` | **Date**: 2026-02-10 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `specs/003-semantic-search/spec.md`

## Summary

Add hybrid search that combines existing ILIKE keyword matching with pgvector cosine similarity via Reciprocal Rank Fusion (RRF). Each result includes a human-readable match explanation. The frontend gains a Smart Search / Keyword toggle and displays match reasons per result. No new database tables or migrations needed — the feature operates on existing `titles` and `content_embeddings` tables.

## Technical Context

**Language/Version**: Python 3.12 (backend), TypeScript 5+ (frontend)
**Primary Dependencies**: FastAPI 0.115+, SQLAlchemy 2.0+ async, sentence-transformers, React 18, TanStack Query, Tailwind CSS 3+
**Storage**: PostgreSQL 16 + pgvector (existing tables only, no migrations)
**Testing**: Manual via Swagger UI + frontend browser testing
**Target Platform**: Docker Compose (localhost)
**Project Type**: Web application (backend + frontend-client)
**Performance Goals**: Search results < 3 seconds including embedding generation
**Constraints**: No Elasticsearch, no LLM/Bedrock, no new cloud dependencies
**Scale/Scope**: 70 titles with 384-dim embeddings, single-user PoC

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. PoC-First Quality | PASS | No production hardening; functional correctness focus |
| II. Monolithic Simplicity | PASS | New service module + endpoint in existing FastAPI app |
| III. AI-Native by Default | PASS | Core feature IS the AI enhancement (semantic search) |
| IV. Docker Compose as Truth | PASS | No external services; runs in existing Docker stack |
| V. Seed Data as Demo | PASS | Uses existing 70-title seed data with embeddings |

**Constraints check:**
- No `version` key in docker-compose: N/A (no compose changes)
- Use `uv` for deps: N/A (no new Python deps — sentence-transformers already installed)
- Single FastAPI process: PASS (new router endpoint, not a new service)
- No cloud dependencies: PASS (all local)

## Project Structure

### Documentation (this feature)

```text
specs/003-semantic-search/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Phase 0: Research decisions
├── data-model.md        # Phase 1: Data model (no changes needed)
├── quickstart.md        # Phase 1: Validation steps
├── contracts/
│   └── semantic-search-api.yaml  # Phase 1: API contract
└── tasks.md             # Phase 2: Task list (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
backend/
├── app/
│   ├── routers/
│   │   └── catalog.py           # MODIFY: Add /search/semantic endpoint
│   ├── schemas/
│   │   └── catalog.py           # MODIFY: Add SearchResultItem, SemanticSearchResponse
│   └── services/
│       ├── search_service.py    # NEW: Hybrid search with RRF
│       ├── catalog_service.py   # READ-ONLY: Reference ILIKE pattern
│       ├── recommendation_service.py  # READ-ONLY: Reference pgvector pattern
│       └── embedding_service.py # READ-ONLY: Reuse generate_embedding()

frontend-client/
├── src/
│   ├── api/
│   │   └── catalog.ts           # MODIFY: Add semanticSearch() + types
│   └── pages/
│       └── SearchPage.tsx       # MODIFY: Mode toggle, AI badge, match reasons
```

**Structure Decision**: Web application structure. Backend adds 1 new file (search_service.py) and modifies 2 existing files. Frontend modifies 2 existing files. No new directories needed.

## Implementation Details

### Step 1: Backend Schemas (`backend/app/schemas/catalog.py`)

Add after `PaginatedResponse` (line 109):
- `SearchResultItem` — extends TitleListItem fields with `match_reason` (str), `match_type` (str), `similarity_score` (float | None)
- `SemanticSearchResponse` — wraps list of SearchResultItem with `total`, `query`, `mode`

### Step 2: Search Service (`backend/app/services/search_service.py`) — NEW

**`keyword_search(db, query, allowed_ratings, limit)`**
- Run ILIKE query (reuse pattern from `catalog_service.py:50-65`)
- For each result, check which fields matched (title, synopsis_short, synopsis_long, cast) by re-testing against the pattern
- Return dicts with title metadata + `match_fields: list[str]`

**`semantic_search(db, query_text, allowed_ratings, limit)`**
- Call `embedding_service.generate_embedding(query_text)` to get 384-dim vector
- Run pgvector cosine query (reuse pattern from `recommendation_service.py:66-87`)
- Remove `WHERE title_id != :source_id` (no source title to exclude)
- Filter results below 0.2 similarity threshold
- Return dicts with title metadata + `similarity_score: float`

**`hybrid_search(db, query_text, mode, allowed_ratings, limit)`**
- Dispatch to keyword_search, semantic_search, or both based on mode
- For hybrid: merge via `_reciprocal_rank_fusion()` (K=60)
- Generate `match_reason` via `_build_match_reason()` using threshold tiers
- Set `match_type` based on which lists contained the result
- Auto-downgrade to keyword for queries < 3 chars
- Wrap `generate_embedding()` in try/except for graceful fallback

### Step 3: API Endpoint (`backend/app/routers/catalog.py`)

Add after line 185 (existing `/search` endpoint):
- `GET /search/semantic` with params: `q` (required), `mode` (default "hybrid"), `page_size` (default 20), `profile_id` (optional)
- Uses `resolve_profile_rating()` for parental filtering (same pattern as existing endpoints)
- Returns `SemanticSearchResponse`

### Step 4: Frontend API Client (`frontend-client/src/api/catalog.ts`)

Add after `getFeatured` (line 105):
- `SearchResultItem` interface (extends TitleListItem + match_reason, match_type, similarity_score)
- `SemanticSearchResponse` interface
- `SemanticSearchParams` interface
- `semanticSearch()` function using `apiFetch` pattern

### Step 5: Frontend SearchPage (`frontend-client/src/pages/SearchPage.tsx`)

Major updates:
- Add `mode` state ('hybrid' | 'keyword', default 'hybrid')
- Switch query from `getTitles()` to `semanticSearch()`
- Add TanStack Query fallback: if semantic errors, retry with `getTitles()`
- Add mode toggle segmented control below search input
- Add AI sparkle badge next to result count when mode != 'keyword'
- Display `match_reason` text below each TitleCard
- Visual match type indicator: left border color (primary=both, teal=semantic, none=keyword)
- Update placeholder: "Try: dark comedy about office life, 90s thriller..."
- Update empty state to suggest natural language queries

## Complexity Tracking

No constitution violations. All changes stay within the existing monolithic FastAPI + React structure.
